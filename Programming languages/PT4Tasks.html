<!-- Programming Taskbook 4.22 | Copyright (c) M. Abramyan, 1998-2022 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>PT4Tasks</title>
<style type="text/css">
H1{font-family:"Arial";font-size:20pt;text-indent:0px;margin-top:10px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
H2{font-family:"Arial";font-size:16pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
P{font-family:"Times New Roman";text-align:left;font-size:12pt;text-indent:0px;margin-top:0px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
TABLE{margin-top:0px; margin-bottom:0px;}
P.ptAuthor{text-align:right;font-size:10pt;font-style:italic;}
P.ptTask{text-align:justify;text-indent:-50px;margin-top:5px; margin-left:60px;}
P.ptTaskQuote{text-align:left;margin-left:120px;margin-top:5px;margin-bottom:0px;}
P.ptTaskCenter{text-align:center;margin-left:60px;margin-top:5px;margin-bottom:0px;}
P.ptTaskContinue{text-align:justify;margin-left:60px;margin-top:5px; }
P.ptComment{text-align:justify;text-indent:50px;margin-top:5px;}
P.ptCommentCenter{text-align:center;margin-top:0px;}
P.ptCommentQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptCommentContinue{text-align:justify;margin-top:0px;}
P.ptFooter{text-align:right;font-size:10pt;font-style:italic;margin-right:0px;}
SPAN.ptSpecial{font-family:"Arial";}
PRE{font-family:"Courier New";text-align:left;font-size:10pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:60px;}
CODE{font-size:10pt;}
TT{font-size:10pt;}
P.ptPicture{font-family:Arial, sans-serif;margin-top: 5px;margin-bottom: 5px;margin-left: 60px;font-size: small;color: #000080;text-indent: 0pt;text-align: justify}
</style>
</head><body>
<h1>Знакомство с&nbsp;запросами LINQ</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2013, 2021</p>
<p class="ptComment"> </p><p class="ptComment">При вводе (выводе) последовательности вначале следует ввести (соответственно, вывести) ее размер, а затем ее элементы. Все входные последовательности являются непустыми. Выходные последовательности могут быть пустыми; в этом случае требуется вывести единственное число 0 &#8212; размер данной последовательности. </p><p class="ptComment">Если в задании идет речь о <i>порядковых номерах</i> элементов последовательности, то предполагается, что нумерация ведется от&nbsp;1 (таким образом, порядковый номер элемента равен <i>индексу</i> этого элемента, <i>увеличенному на</i>&nbsp;1). </p><p class="ptComment">Для обработки входной последовательности в большинстве заданий достаточно указать <i>единственный</i> оператор, содержащий вызовы нужных запросов LINQ to Objects и другие необходимые конструкции, в частности, операцию <tt>??</tt> языка C# (в VB.NET, начиная с версии 9.0, аналогом этой операции является бинарная операция <tt>If</tt>). </p><p class="ptComment">При выполнении заданий с использованием задачника Programming Taskbook можно использовать дополнительные методы, определенные в задачнике: </p><p class="ptComment">&#8226; методы <tt>GetEnumerableInt</tt> и <tt>GetEnumerableString</tt> (<tt>ReadSeqInteger</tt> и <tt>ReadSeqString</tt> в PascalABC.NET) обеспечивают ввод исходных последовательностей с элементами целого и строкового типа соответственно (выполняется ввод размера последовательности и всех ее элементов, возвращается введенная последовательность); </p><p class="ptComment">&#8226; метод <tt>Put</tt> (<tt>WriteAll</tt> в PascalABC.NET) является методом расширения для последовательности и обеспечивает вывод этой последовательности (выводится размер последовательности и все ее элементы); </p><p class="ptComment">&#8226; метод <tt>Show</tt> также является методом расширения для последовательности; он обеспечивает печать последовательности в разделе отладки окна задачника и возвращает эту же последовательность (отладочная печать может сопровождаться <i>комментарием</i>, который указывается в качестве необязательного строкового параметра метода <tt>Show</tt>). </p><p class="ptComment">Использование вспомогательных методов иллюстрируется приведенным ниже фрагментом программы, решающей следующую задачу: извлечь из исходной целочисленной последовательности четные отрицательные числа и заменить порядок их следования на обратный. </p><p class="ptComment">[C#] </p><p class="ptCommentQuote"><i>// Ввод исходных данных</i><br><tt>var a = GetEnumerableInt();</tt><br><i>// Обработка</i><br><tt>var res = a.Where(e =&gt; e % 2 == 0 &amp;&amp; e &lt; 0).Reverse();</tt><br><i>// Вывод результатов</i><br><tt>res.Put();</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[VB.NET] </p><p class="ptCommentQuote"><i>' Ввод исходных данных</i><br><tt>Dim a = GetEnumerableInt()</tt><br><i>' Обработка</i><br><tt>Dim res = a.Where(Function(e) e Mod 2 = 0 AndAlso e &lt; 0).Reverse()</tt><br><i>' Вывод результатов</i><br><tt>res.Put()</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[PascalABC.NET] </p><p class="ptCommentQuote"><i>// Ввод исходных данных</i><br><tt>var a := ReadSeqInteger;</tt><br><i>// Обработка</i><br><tt>var res := a.Where(e -&gt; (e mod 2 = 0) and (e &lt; 0)).Reverse;</tt><br><i>// Вывод результатов</i><br><tt>res.WriteAll;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">Все этапы решения можно объединить в одном операторе, состоящем из цепочки последовательно вызываемых методов: </p><p class="ptComment">[C#] </p><p class="ptCommentQuote"><tt>GetEnumerableInt().Where(e =&gt; e % 2 == 0 &amp;&amp; e &lt; 0)</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Reverse().Put();</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[VB.NET] </p><p class="ptCommentQuote"><tt>GetEnumerableInt().Where(Function(e) e Mod 2 = 0 AndAlso e &lt; 0) _</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Reverse().Put()</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[PascalABC.NET] </p><p class="ptCommentQuote"><tt>ReadSeqInteger.Where(e -&gt; (e mod 2 = 0) and (e &lt; 0))</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Reverse.WriteAll;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">Возможен вариант решения, в котором дополнительно выполняется отладочная печать (в данном случае полученная последовательность четных отрицательных чисел печатается перед изменением порядка следования ее элементов и после этого изменения): </p><p class="ptComment">[C#] </p><p class="ptCommentQuote"><tt>GetEnumerableInt().Where(e =&gt; e % 2 == 0 &amp;&amp; e &lt; 0)</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Show().Reverse().Show().Put();</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[VB.NET] </p><p class="ptCommentQuote"><tt>GetEnumerableInt().Where(Function(e) e Mod 2 = 0 AndAlso e &lt; 0) _</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Show().Reverse().Show().Put()</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[PascalABC.NET] </p><p class="ptCommentQuote"><tt>ReadSeqInteger.Where(e -&gt; (e mod 2 = 0) and (e &lt; 0))</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Show.Reverse.Show.WriteAll;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">Отладочная печать позволяет увидеть состояние последовательности на различных этапах ее преобразования и тем самым облегчает поиск ошибок.</p>
<h2>Поэлементные операции, агрегирование и&nbsp;генерирование последовательностей</h2>
<p class="ptComment"> </p><p class="ptComment">Изучаемые методы LINQ: </p><p class="ptCommentQuote">&#8226; First, FirstOrDefault, Last, LastOrDefault, Single, SingleOrDefault (поэлементные операции);<br>&#8226; Count, Sum, Average, Max, Min, Aggregate (агрегирование);<br>&#8226; Range (генерирование последовательностей).</p>
<p class="ptTask"><span class="ptSpecial">LinqBegin12°</span>. Дана целочисленная последовательность. Используя метод Aggregate, найти произведение последних цифр всех элементов последовательности. Чтобы избежать целочисленного переполнения, при вычислении произведения использовать вещественный числовой тип. </p>
<hr noshade>
<p class="ptFooter">Page generation date: 2022/6/3.</p>
</body></html>
